<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="API documentation for the Rust `consumer` mod in crate `sui_proxy`."><title>sui_proxy::consumer - Rust</title><script>if(window.location.protocol!=="file:")document.head.insertAdjacentHTML("beforeend","SourceSerif4-Regular-46f98efaafac5295.ttf.woff2,FiraSans-Regular-018c141bf0843ffd.woff2,FiraSans-Medium-8f9a781e4970d388.woff2,SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2,SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2".split(",").map(f=>`<link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/${f}">`).join(""))</script><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-c5d6553a23f1e5a6.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="sui_proxy" data-themes="" data-resource-suffix="" data-rustdoc-version="1.81.0 (eeb90cda1 2024-09-04)" data-channel="1.81.0" data-search-js="search-d234aafac6c221dd.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-118b08c4c78b968e.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-d2fab2bf619172d3.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-df360f571f6edeae.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle" title="show sidebar"></button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../sui_proxy/index.html">sui_proxy</a><span class="version">0.0.2</span></h2></div><h2 class="location"><a href="#">Module consumer</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#functions">Functions</a></li></ul></section><h2><a href="../index.html">In crate sui_proxy</a></h2></div></nav><div class="sidebar-resizer"></div><main><div class="width-limiter"><rustdoc-search></rustdoc-search><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">sui_proxy</a>::<wbr><a class="mod" href="#">consumer</a><button id="copy-path" title="Copy item path to clipboard">Copy item path</button></h1><span class="out-of-band"><a class="src" href="../../src/sui_proxy/consumer.rs.html#4-379">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><h2 id="structs" class="section-header">Structs<a href="#structs" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.NodeMetric.html" title="struct sui_proxy::consumer::NodeMetric">NodeMetric</a></div><div class="desc docblock-short">NodeMetric holds metadata and a metric payload from the calling node</div></li><li><div class="item-name"><a class="struct" href="struct.ProtobufDecoder.html" title="struct sui_proxy::consumer::ProtobufDecoder">ProtobufDecoder</a></div><div class="desc docblock-short">The ProtobufDecoder will decode message delimited protobuf messages from prom_model.proto types
They are delimited by size, eg a format is such:
[]byte{size, data, size, data, size, data}, etc etc</div></li></ul><h2 id="functions" class="section-header">Functions<a href="#functions" class="anchor">§</a></h2><ul class="item-table"><li><div class="item-name"><a class="fn" href="fn.convert_to_remote_write.html" title="fn sui_proxy::consumer::convert_to_remote_write">convert_to_remote_write</a></div><div class="desc docblock-short">convert_to_remote_write is an expensive method due to the time it takes to submit to mimir.
other operations here are optimized for async, within reason.  The post process uses a single
connection to mimir and thus incurs the seriliaztion delay for each metric family sent. Possible
future optimizations would be to use multiple tcp connections to mimir, within reason. Nevertheless
we await on each post of each metric family so it shouldn’t block any other async work in a
significant way.</div></li><li><div class="item-name"><a class="fn" href="fn.populate_labels.html" title="fn sui_proxy::consumer::populate_labels">populate_labels</a></div></li></ul></section></div></main></body></html>